#ifndef UPNPLIB_SOCKET_HPP
#define UPNPLIB_SOCKET_HPP
// Copyright (C) 2023+ GPL 3 and higher by Ingo HÃ¶ft, <Ingo@Hoeft-online.de>
// Redistribution only with this Copyright remark. Last modified: 2024-04-23
/*!
 * \file
 * \brief **Socket Module:** manage properties and methods but not connections
 * of ONE network socket to handle IPv4 and IPv6 streams and datagrams.
 */

/*!
 * \addtogroup upnplibAPI-socket
* Helpful link for ip address structures:
<!--REF:-->[sockaddr&#20;structures&#20;as&#20;union](https://stackoverflow.com/a/76548581/5014688).

* This module mainly consists of the CSocket class but also provides free
* functions to manage a socket. The problem is that socket handling isn't very
* good portable. There is different behavior on the supported platforms Unix,
* MacOS and Microsoft Windows. The CSocket class atempts to be consistent
* portable on all three platforms by using common behavior or by emulating
* missing functions on a platform.
*
* Specification for CSocket
* =========================
* The class encapsulates and manages one raw socket file descriptor. The file
* descriptor of a valid socket object cannot be changed but the object with
* its immutable file descriptor can be moved and assigned to another socket
* object. Copying a socket object isn't supported because having two objects
* with the same file descriptor may be very error prone in particular with
* multithreading. Effort has been taken to do not cache any socket information
* outside the socket file descriptor. All socket informations are direct set
* and get to/from the operating system with the file descriptor. The socket
* file descriptor is always valid except on an empty socket object.
*
* empty socket object
* -------------------
* An empty socket object can be instantiated with the default constructor,
* e.g. `CSocket sockObj;`. It is a valid object and should be destructed. When
* moving a socket object, the left over source object is also empty. An empty
* socket object has an `INVALID_SOCKET` defined and no valid content. It
* throws an exception if using any of its Setter and Getter. Moving and
* assigning it is possible.
*
* address family
* --------------
* Only address family `AF_INET6` and `AF_INET` is supported. Any other address
* family throws an exception.
*
* socket type
* -----------
* Only `SOCK_STREAM` and `SOCK_DGRAM` is supported. Any other type throws an
* exception.
*
* valid socket file descriptor
* ----------------------------
* I get this from the C standard library function:
* `int ::%socket(address_family, socket_type, protocol)`.
* Other arguments than address family and socket type do not instantiate a
* valid socket object and throw an exception. For the protocol argument is
* always the default one used that is internal hard coded with argument 0.
*
* options SO_REUSEADDR and SO_EXCLUSIVEADDRUSE
* --------------------------------------------
* I don't set the option to immediately reuse an address and I always set the
* option `SO_EXCLUSIVEADDRUSE` on Microsoft Windows. For more details of this
* have a look at
[Socket&#20;option&#20;"reuse&#20;address"](\ref&#20;overview_reuseaddr).
*/

#include <upnplib/sockaddr.hpp>
/// \cond
#include <mutex>
#include <memory>

// To be portable with BSD socket error number constants I have to
// define and use these macros with appended 'P' for portable.
#ifdef _MSC_VER
#define EBADFP WSAENOTSOCK
#define ENOTCONNP WSAENOTCONN
#define EINTRP WSAEINTR
#define EFAULTP WSAEFAULT
#define ENOMEMP WSA_NOT_ENOUGH_MEMORY
#else
#define EBADFP EBADF
#define ENOTCONNP ENOTCONN
#define EINTRP EINTR
#define EFAULTP EFAULT
#define ENOMEMP ENOMEM
#endif
/// \endcond

namespace upnplib {

/*!
 * \brief Manage basic issues of a network socket
 * \ingroup upnplibAPI-socket
 * \ingroup upnplib-socket
 *
 * This class takes the resources and results as given by the platform (Unix,
 * MacOS, MS Windows). It does not perform any emulations for unification. The
 * behavior can be different on different platforms.
 */
class UPNPLIB_API CSocket_basic : private SSockaddr {
  protected:
    /*! \brief Default constructor for an empty socket object, but only provided
     * for derived classes. */
    CSocket_basic();

  public:
    /*! \brief Constructor with given file desciptor
     *
     * This instantiate a socket object from a raw socket file descriptor. It
     * throws an exception if the raw socket argument is invalid. It does not
     * take ownership of the socket file descriptor and will never close it.
     * This is in the responsibility of the caller who created the socket.
     *
     * Throws exception std::runtime_error. */
    CSocket_basic(SOCKET);

    // Copy constructor
    // not generated by default with custom move constructor. I want to
    // restrict to only move the resource. Don't enable this.
    // CSocket(const CSocket&);

    // Destructor
    virtual ~CSocket_basic();

    /*! \brief Get raw socket file descriptor.
     * \code
     * // usage:
     * CSocket_basic sockObj(valid_socket_fd);
     * SOCKET sfd = sockObj;
     * \endcode */
    operator const SOCKET&() const;

    // Getter
    // ------
    /*! \brief Get socket [address family](\ref glossary_af)
     *
     * Throws no exception. */
    sa_family_t get_family() const;

    /*! \brief Get [netaddress](\ref glossary_netaddr) without port.
     *
     * Throws no exception. */
    const std::string& get_addr_str() override;

    /*! \brief Get [netaddress](\ref glossary_netaddr) with port.
     *
     * Throws no exception. */
    const std::string& get_addrp_str() override;

    /*! \brief Get the [port](\ref glossary_port) number.
     *
     * Throws no exception. */
    in_port_t get_port() const override;

    /*! \brief Get the [socket type](\ref glossary_socktype) `SOCK_STREAM` or
     * `SOCK_DGRAM`.
     *
     * Throws exception std::runtime_error if query option fails. */
    int get_socktype() const;

    /*! \brief Get the error that is given from the socket as option.
     *
     * This is not a system error from the operating system (with POSIX
     * returned in errno). It is the more specific error that can be queried as
     * option from the socket.
     *
     * Throws exception std::runtime_error if query option fails. */
    int get_sockerr() const;

    /*! \brief Get status if reusing address is enabled.
     *
     * Throws exception std::runtime_error if query option fails. */
    bool is_reuse_addr() const;

    /*! \brief Get status if socket is bound to a local netaddress.
     *
     * I assume that a valid socket file descriptor with unknown address (all
     * zero) and port 0 is not bound. */
    bool is_bound();

  protected:
    /// \brief This is the raw socket file descriptor
    SOCKET m_sfd{INVALID_SOCKET};

    // Mutex to protect concurrent binding a socket.
    /// \cond
    SUPPRESS_MSVC_WARN_4251_NEXT_LINE
    mutable std::mutex m_bound_mutex;
    /// \endcond

  private:
    // Helper method
    void m_get_addr_from_socket(int line) const;
};


/*!
 * \brief Manage all aspects of a network socket.
 * \ingroup upnplibAPI-socket
 * \ingroup upnplib-socket
 */
class UPNPLIB_API CSocket : public CSocket_basic {
  public:
    /// \brief Default constructor for an empty socket object
    CSocket();

    /// \brief Constructor for a socket with file descriptor
    CSocket(sa_family_t a_family, int a_socktype);

    /// \brief Move constructor
    CSocket(CSocket&&);

    /*! \brief Assignment operator
     *
     * With parameter as value this is used as copy- and move-assignment
     * operator. The correct usage (move) is evaluated by the compiler. Here
     * only the move constructor can be used (there is no copy constructor) to
     * move the parameter to the function body. */
    CSocket& operator=(CSocket);

    /// \brief Destructor
    virtual ~CSocket();

    // Setter
    // ------
    /*! \brief Set socket to bind
     *
     * I use a string argument for a_port to be able to use service names
     * instead of only numbers. */
    void bind(const std::string& a_node, const std::string& a_port,
              const int a_flags = 0);

    /*! \brief Set socket to listen
     *
     * On Linux there is a socket option SO_ACCEPTCONN that can be get with
     * system function ::%getsockopt(). This option shows if the socket is set
     * to passive listen. But it is not portable. MacOS does not support it. So
     * this flag has to be managed here. Look for details at
     * <!--REF:-->[How_to_get_option_on_MacOS_if_a_socket_is_set_to_listen?](https://stackoverflow.com/q/75942911/5014688)
     */
    void listen();

    /*! \brief Set IPV6_V6ONLY
     * - IPV6_V6ONLY = false means allowing IPv4 and IPv6.
     * - This flag can only be set on sockets of address family AF_INET6.
     * - It is always false on a socket with address family AF_INET.
     * - It is always true on Unix platforms after binding a socket to an
     *   address of family AF_INET6 if passive mode isn't set on the address
     *   info (flag AI_PASSIVE).
     * - With an address info set to passive listen on local addresses (flag
     *   AI_PASSIVE) IPV6_V6ONLY can be modified before binding it to an
     *   address. After bind it hasn't changed. This means the socket can
     *   listen to IPv6 and IPv4 connections if IPV6_V6ONLY is set to false.
     * - It can never be modified on a sochet that is bound to an address.
     *
     * If one of the conditions above doesn't match, the setter silently
     * ignores the request and will not modify the socket. Other system errors
     * may throw an exception (e.g. using an invalid socket etc.).
     *
     * To get the current setting use CSocket::is_v6only(). */
    void set_v6only(const bool);


    // Getter
    // ------
    /*! \brief Get status of IPV6_V6ONLY flag
     *
     * IPV6_V6ONLY == false means allowing IPv4 and IPv6. */
    bool is_v6only() const;

    /// \brief Get status if the socket is listen to incomming network packets.
    bool is_listen() const;

  private:
    /// \brief Mutex to protect concurrent listen a socket.
    SUPPRESS_MSVC_WARN_4251_NEXT_LINE
    mutable std::mutex m_listen_mutex;
    bool m_listen{false}; // Protected by a mutex.
};


// Initialize and cleanup Microsoft Windows Sockets
// ================================================
// Winsock needs to be initialized before using it and it needs to be freed. I
// do that with a class, following the RAII paradigm. Multiple initialization
// doesn't matter. This is managed by the operating system with a counter. It
// ensures that winsock is initialzed only one time and freed with the last
// free call. --Ingo

#ifdef _MSC_VER
class UPNPLIB_API CWSAStartup {
  public:
    CWSAStartup();
    virtual ~CWSAStartup();
};

#define WINSOCK_INIT upnplib::CWSAStartup winsock_init;
#else
#define WINSOCK_INIT
#endif // _MSC_VER


/*!
 * \brief Portable catch **one** network socket error from the operating
 * system, and provide information about it.
 * \ingroup upnplibAPI-socket
 * \ingroup upnplib-socket
 *
 * This is a C++ interface for dependency injection of different
 * \glos{depinj,di-services}, e.g. for production or Unit Tests (mocking).
 */
class UPNPLIB_API ISocketErr {
  public:
    ISocketErr();
    virtual ~ISocketErr();
    /// Get error number.
    virtual operator const int&() = 0;
    /// Catch error for later use.
    virtual void catch_error() = 0;
    /// Get human readable error description of the catched error.
    virtual std::string get_error_str() const = 0;
};

/*!
 * \brief Smart pointer to \glos{depinj,di-service} objects that handle network
 * socket errors and used to inject the objects.
 * \ingroup upnplib-socket
 */
using PSocketErr = std::shared_ptr<ISocketErr>;

/*!
 * \brief \glos{depinj,di-service} for portable handling of network socket
 * errors.
 * \ingroup upnplibAPI-socket
 * \ingroup upnplib-socket
 *
 * There is a compatibility problem with Winsock2 on the Microsoft Windows
 * platform that does not support detailed error information given in the global
 * variable 'errno' that is used by POSIX. Instead it returns them with calling
 * 'WSAGetLastError()'. This class encapsulates differences so there is no need
 * to always check the platform to get the error information.
 */
class UPNPLIB_API CSocketErrService : public ISocketErr {
  public:
    CSocketErrService();
    virtual ~CSocketErrService() override;
    /// Get error number.
    virtual operator const int&() override;
    /// Catch error for later use.
    virtual void catch_error() override;
    /// Get human readable error description of the catched error.
    virtual std::string get_error_str() const override;

  private:
    int m_errno{}; // Cached error number
};

/*!
 * \brief \glos{depinj,di-client} for portable handling of network socket
 * errors with injected \glos{depinj,di-service}.
 * \ingroup upnplibAPI-socket
 * \ingroup upnplib-socket
 *
 * Usage of the class:
 * \code
 * CSocketErrService sockerrObj;
 * int ret = some_function_1();
 * if (ret != 0) {
 *     sockerrObj.catch_error();
 *     int errid = sockerrObj;
 *     std::cout << "Error " << errid << ": "
 *               << sockerrObj.get_error_str() << "\n";
 * }
 * ret = some_function_2();
 * if (ret != 0) {
 *     sockerrObj.catch_error();
 *     std::cout << "Error " << static_cast<int>(sockerrObj) << ": "
 *               << sockerrObj.get_error_str() << "\n";
 * }
 * \endcode
 */
class CSocketErr {
    // Due to warning C4251 "'type' : class 'type1' needs to have dll-interface
    // to be used by clients of class 'type2'" on Microsoft Windows each member
    // function needs to be decorated with UPNPLIB_API instead of just only the
    // class. The reason is 'm_socket_errObj'.
  public:
    /*! \brief Constructor */
    UPNPLIB_API CSocketErr(
        /*! [in] Inject the used \glos{depinj,di-service} object that is by
         * default the productive one but may also be a mocked object for Unit
         * Tests. */
        PSocketErr a_socket_errObj = std::make_shared<CSocketErrService>());

    /* \brief Destructor */
    UPNPLIB_API virtual ~CSocketErr();

    /*! \brief Get the catched error number.
     * \details The error number is that from the operating system, for example
     * **errno** on Posix platforms or from WSAGetLastError() on Microroft
     * Windows. */
    UPNPLIB_API virtual operator const int&();

    /*! \brief Catches detailed error information.
     *  \details Because error information from the operating system is very
     * volatile this method should be called as early as possible after the
     * error was detected. */
    UPNPLIB_API virtual void catch_error();

    /*! \brief Gets a human readable error description from the operating
     * system that explains the catched error. */
    UPNPLIB_API virtual std::string get_error_str() const;

  private:
    PSocketErr m_socket_errObj;
};

} // namespace upnplib

#endif // UPNPLIB_SOCKET_HPP
