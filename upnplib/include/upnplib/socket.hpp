#ifndef UPNPLIB_SOCKET_CLASS_HPP
#define UPNPLIB_SOCKET_CLASS_HPP
// Copyright (C) 2023+ GPL 3 and higher by Ingo HÃ¶ft, <Ingo@Hoeft-online.de>
// Redistribution only with this Copyright remark. Last modified: 2023-04-16

// Helpful link for ip address structures:
// https://stackoverflow.com/a/16010670/5014688

#include <upnplib/visibility.hpp>
#include <upnplib/port_sock.hpp>
#include <upnplib/addrinfo.hpp>
#include <mutex>

namespace upnplib {

// Initialize and cleanup Microsoft Windows Sockets portable
// ---------------------------------------------------------
#ifdef _MSC_VER
class UPNPLIB_API CWSAStartup {
  public:
    CWSAStartup();
    virtual ~CWSAStartup();
};
// Winsock Init Portable
#define WINSOCK_INIT_P CWSAStartup winsock_init;
#else
#define WINSOCK_INIT_P
#endif


// Wrap socket() system call
// -------------------------
// To copy a socket doesn't make sense. So this class only supports moving a
// socket. After moving, the moved-from object is still valid but contains an
// INVALID_SOCKET. It can be successful destructed.
// An instantiation of this class without arguments or all arguments set to 0
// will give an empty object. You can move another usable CSocket to it.
// REF: [What is move semantics?](https://stackoverflow.com/q/3106110/5014688)

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4251)
// REF: 'type' : class 'type1' needs to have dll-interface to be used by clients
// of class 'type2'. C4251 can be ignored if your class is derived from a type
// in the C++ Standard Library.
// https://learn.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-1-c4251
#endif

class UPNPLIB_API CSocket {
  public:
    // Constructor for new socket file descriptor
    // Using this Constructor without arguments or all arguments set to 0
    // will give an empty object. With arguments it will get a valid socket.
    CSocket(int a_domain = 0, int a_type = 0, int a_protocol = 0);

    // Constructor with given file desciptor
    // This instantiate a socket object from a raw socket file descriptor. It
    // throws an exception if the raw socket argument is already in use or
    // invalid.
    CSocket(SOCKET);

    // Copy constructor
    // not generated by default with custom move member functions. We want to
    // restrict to only move the resource.
    // CSocket(const CSocket&);

    // Move constructor
    CSocket(CSocket&&);

    // Assignment operator
    // With parameter as value this is used as copy- and move-assignment
    // operator. The correct usage (move) is evaluated by the compiler. Here
    // only the move constructor can be used (there is no copy constructor) to
    // move the parameter to the function body.
    CSocket& operator=(CSocket);

    // Destructor
    virtual ~CSocket();

    // Get the socket, e.g.: CSocket sock; SOCKET sfd = sock;
    operator SOCKET&() const;

    // Setter: set socket to bind.
    // Binding a socket address (given with CAddrinfo) with a different socket
    // type (e.g. SOCK_STREAM, SOCK_DGRAM, etc.) than that of the socket is not
    // supported and throw an error.
    void bind(const CAddrinfo& a_addrObj);

    // Setter: set socket to listen.
    // On Linux there is a socket option SO_ACCEPTCONN that can be get with
    // system function ::getsockopt(). This option shows if the socket is set to
    // passive listen. But it is not portable. MacOS does not support it. So
    // this flag has to be managed here. Look for details at
    // REF: [How to get option on MacOS if a socket is set to listen?]
    //      (https://stackoverflow.com/q/75942911/5014688)
    void listen();

    // Getter
    // get_addr_str() throws an error if the socket is not bound.
    std::string get_addr_str() const;
    // get_port() throws an error if the socket is not bound.
    uint16_t get_port() const;
    int get_sockerr() const;
    bool is_reuse_addr() const;
    bool is_v6only() const;
    bool is_bind() const;
    bool is_listen() const;

  private:
    SOCKET m_sfd{INVALID_SOCKET};

    // We could use getsockopt() with SO_DOMAIN to get the address family
    // direct from the socket. But this is only supported on Linux platforms,
    // not on MacOS. To be portable it is needed to cache it.
    int m_af{-1}; // used address family e.g. AF_INET6

    // Cache if other system functions where called.
    mutable std::mutex m_bound_mutex;
    bool m_bound{false}; // Protected by a mutex.
    mutable std::mutex m_listen_mutex;
    bool m_listen{false}; // Protected by a mutex.

    UPNPLIB_LOCAL int get_sockopt_int(int a_level, int a_optname,
                                      const std::string& a_optname_str) const;

    UPNPLIB_LOCAL void get_sockname(sockaddr_storage*) const;
};

#ifdef _MSC_VER
#pragma warning(pop)
#endif

} // namespace upnplib

#endif // UPNPLIB_SOCKET_CLASS_HPP
